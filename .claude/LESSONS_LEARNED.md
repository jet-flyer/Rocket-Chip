# Lessons Learned - Debugging Journal

**Purpose:** Document significant debugging efforts and their solutions so Claude can learn from past issues and avoid repeating mistakes.

**Format:** Each entry includes the problem, symptoms, root cause, solution, and time spent to emphasize the importance of the lesson.

> **Note:** FreeRTOS-specific entries (7, 8, 9, 10, 14, 17, 18, 19) archived with `AP_FreeRTOS` branch during bare-metal pivot. Original entry numbers preserved for traceability.

---

## Plan Files Reference

Plan mode stores plans at `C:\Users\pow-w\.claude\plans\<auto-generated-name>.md`. These persist outside conversations.

**Active Plans:**
- `virtual-scribbling-finch.md` - AP_Vehicle integration for calibration persistence (2026-01-31)

---

## Entry 1: Stack Overflow from Large Local Variables

**Date:** 2026-01-26
**Time Spent:** ~2 hours of debugging
**Severity:** Critical - Silent crashes with no error message

### Problem
Test was crashing mysteriously. Output would appear up to a certain point, then nothing. Crash point seemed to move around between rebuilds.

### Symptoms
- Test prints some output (e.g., "Max fitness: 5.0") then stops
- No error message, no crash dump
- LED/NeoPixel may or may not continue
- Crash point appears random but is actually at function entry
- Clean rebuild sometimes "fixes" it temporarily (different stack layout)

### Root Cause
`CompassCalibrator calibrator;` declared as local variable in `main()`. The CompassCalibrator object is ~3KB+, exceeding available stack space.

**Key insight:** Compiler pre-allocates ALL stack space at function entry, not when variables are used. So even though the crash "appears" to happen after several printf statements, the stack overflow actually occurs immediately when main() is entered.

### Solution
Use static allocation for large objects:

```cpp
// At file scope (outside any function)
static CompassCalibrator g_calibrator;

int main() {
    // Use g_calibrator instead of local variable
    g_calibrator.start(...);
}
```

### How to Identify This Issue
1. Crash point seems to move around between builds
2. Adding/removing printf changes where crash appears
3. Object being created is large (>1KB)
4. Crash happens "between" two printf statements

### Prevention
- Any object >1KB should be static or heap-allocated
- Known large objects: CompassCalibrator, any object with large buffers
- When debugging mysterious crashes, check for large local variables

---

## Entry 2: Version Strings for Iterative Debugging

**Date:** 2026-01-26
**Context:** Debugging stack overflow issue above

### Problem
During iterative debugging, it was unclear if the latest code was actually running. Sometimes old binaries were being executed, wasting debugging time.

### Solution
Add a version string to debug output that changes with each significant code change:

```cpp
printf("Build: v3-static-calibrator\n");
```

Update the version string whenever making changes during debugging sessions. This immediately confirms whether the expected code is running.

### Prevention
- Always add version strings when doing iterative debugging
- Update version string on each significant change
- Check version string first before analyzing other output

---

## Entry 3: BASEPRI Register Blocking USB Interrupts

**Date:** 2026-01-26 (earlier in same session)
**Time Spent:** ~30 minutes

### Problem
USB CDC output not working after initialization code that elevates interrupt priority masking. Terminal shows nothing or partial output.

### Root Cause
Initialization code (HAL, library init, etc.) can leave the ARM BASEPRI register elevated, which blocks USB interrupts.

### Solution
Clear BASEPRI after any init code that might elevate it, before USB I/O:

```cpp
// After init code that might change interrupt priorities
__asm volatile ("mov r0, #0\nmsr basepri, r0" ::: "r0");
stdio_init_all();
```

### Prevention
- If USB stops working after adding init code, check BASEPRI
- Clear BASEPRI before enabling USB if uncertain

---

## Entry 4: Flash Operations Break USB

**Date:** 2026-01-26

### Problem
USB CDC breaks after flash operations during initialization.

### Root Cause
Flash operations make entire flash inaccessible. TinyUSB interrupt handlers are in flash. If USB is active during flash ops, handlers can't execute and USB breaks.

### Solution
Do flash operations BEFORE enabling USB:

```cpp
// Flash ops happen here (calibration load, storage init, etc.)
init_storage();

// NOW safe to start USB
stdio_init_all();
```

### Prevention
- Follow this init order: flash ops first, then USB
- Use `flash_safe_execute()` from `pico/flash.h` for runtime flash access

---

## Entry 5: Use Debug Probe Before Manual BOOTSEL

**Date:** 2026-01-26

### Problem
When debugging crashes, kept asking user to manually reset into BOOTSEL mode when the device became unresponsive.

### Better Approach
Debug probe can always flash the device, even when USB is completely broken:

```bash
arm-none-eabi-gdb firmware.elf -batch \
  -ex "target extended-remote localhost:3333" \
  -ex "monitor reset halt" \
  -ex "load" \
  -ex "monitor reset run"
```

### Prevention
- Always try debug probe first when USB is unresponsive
- Only ask for manual BOOTSEL as last resort
- Keep OpenOCD running during debugging sessions

---

## Entry 6: WS2812/NeoPixel Requires begin() Call

**Date:** 2026-01-26
**Time Spent:** ~1 session (issue not immediately identified)

### Problem
NeoPixel LED was not lighting up at all during compass calibration test, despite code appearing to set colors and call show().

### Symptoms
- LED completely dark, no response to any color commands
- No errors or warnings
- Code runs to completion without issues
- Other test code (without HAL) may show working NeoPixel

### Root Cause
The RocketChip WS2812 class follows standard pattern: construct → `begin()` → use. The `begin()` method:
1. Allocates the pixel buffer
2. Allocates a PIO state machine
3. Loads the PIO program
4. Sets `m_initialized = true`

Without `begin()`, both `setPixel()` and `show()` silently return early:
```cpp
void WS2812::setPixel(uint16_t index, const RGB& color) {
    if (!m_initialized || index >= m_num_leds) {
        return;  // Silent early return!
    }
    // ...
}
```

### Solution
Always call `begin()` after constructing WS2812:

```cpp
g_statusLed = new rh::WS2812(kNeoPixelPin, 1);
if (!g_statusLed->begin()) {
    // Handle init failure
}
g_statusLed->fill(rh::Colors::YELLOW);
g_statusLed->show();
```

### Prevention
- Always follow the construct → begin → use pattern for hardware classes
- Check return value of begin() for failure handling
- When LED doesn't respond, verify begin() was called before assuming hardware issue

---

## Entry 11: Prioritize Debug Probe Over LED Debugging

**Date:** 2026-01-29
**Context:** Multiple debugging sessions where USB was broken
**Severity:** Process Improvement - Saves hours of debugging time

### Problem
When encountering issues that break output (USB enumeration failures, hardfaults, early crashes), default instinct was to add LED blink patterns for diagnostics. This provided minimal information and required many flash/test cycles.

### Better Approach
**Always use the debug probe first.** It provides:
- Register and memory inspection via GDB
- Stack traces showing exact crash location
- Ability to flash even when USB is completely broken
- Variable inspection without modifying code

### Occasional Connection Quirks (Expected)
The probe connection may have transient issues:
- OpenOCD timeout on first attempt
- "Remote communication error" from GDB
- Need to run `monitor reset halt` multiple times

**These are normal** - retry and it works. The probe has proven reliable in extensive debugging sessions. Don't give up after one failed attempt.

### When LED Debugging Makes Sense
Only resort to LED-based debugging when:
- Debug probe is not physically connected
- Observing runtime behavior without breakpoints
- Testing production firmware without probe

### Key Takeaway
The few seconds spent reconnecting a flaky probe connection saves hours compared to iterating with LED blink codes. The probe gives you answers; LEDs give you hints.

---

## Entry 12: USB CDC Init Order Critical for Enumeration

**Date:** 2026-01-29
**Time Spent:** ~1 hour
**Severity:** Critical - USB completely broken (error 2)

### Problem
USB CDC (COM6) failed to enumerate. Device showed "error 2" in Device Manager. Serial output completely broken.

### Symptoms
- USB device doesn't appear in Device Manager
- "error 2" when device tries to enumerate
- LED blink patterns visible (code is running)
- Manual BOOTSEL required to flash

### Root Cause
Init order was wrong — flash operations happened after USB was already active:

**BROKEN order:**
```cpp
stdio_init_all();           // USB starts first
init_storage();             // Flash ops break USB!
```

Flash operations make entire flash inaccessible. TinyUSB interrupt handlers are in flash. When USB is active during flash ops, handlers can't execute and USB breaks permanently.

### Solution
Reorder init:

**WORKING order:**
```cpp
// 1. Flash ops BEFORE USB
init_storage();             // Flash ops complete here

// 2. NOW safe to start USB
stdio_init_all();
```

### Prevention
- **Rule:** Flash operations MUST happen before `stdio_init_all()`
- This is the same root cause as Entry 4

### Related
- Entry 3: BASEPRI blocking USB
- Entry 4: Flash/USB interaction

---

## Entry 13: Adafruit ICM-20948 Default I2C Address is 0x69, not 0x68

**Date:** 2026-01-29
**Time Spent:** ~20 minutes
**Severity:** High - IMU not detected, silent failure

### Problem
IMU (ICM-20948) not being detected. Barometer worked fine (proving I2C bus functional), but zero I2C traffic to the IMU address.

### Symptoms
- Barometer working at 0x77
- IMU: no traffic to 0x68
- I2C debug output shows only 0x77 transfers, never 0x68

### Root Cause
Configuration used **0x68** as the ICM-20948 address, but **Adafruit boards default to 0x69**.

The ICM-20948 has an AD0 pin that controls I2C address:
- AD0 = LOW (grounded) → 0x68
- AD0 = HIGH (or floating) → 0x69

**Adafruit boards pull AD0 HIGH by default**, giving address 0x69. You must bridge the SDO/ADR solder jumper on the back to change to 0x68.

### Solution
Use 0x69 for Adafruit ICM-20948 breakouts (already set in `config.h`).

### Prevention
1. **Always check vendor documentation for default I2C addresses**
2. Run I2C scan test to confirm actual device addresses before configuring
3. For Adafruit boards: check product page or schematic for default pin states
4. Add comments noting whether addresses are vendor defaults vs modified

### Reference
Adafruit ICM-20948 product page confirms 0x69 as default:
https://learn.adafruit.com/adafruit-tdk-invensense-icm-20948-9-dof-imu/pinouts

---

## Entry 15: USB Terminal Connection Affecting Program State

**Date:** 2026-01-30
**Status:** RESOLVED (v0.3.14)
**Severity:** High - CLI unusable
**Time Spent:** ~4 hours (architecture redesign + debugging)

### Problem
CLI stops executing when USB terminal connects. Program behavior should NOT depend on terminal connection - only output buffering should be affected.

### Symptoms
- LED flashes rapidly (50ms) while waiting for sensor init - CORRECT
- When terminal connects to COM6, LED goes SOLID - WRONG
- Pressing Enter does nothing
- Program appears frozen

### Root Cause Analysis
The old CLI architecture was **too tightly coupled** to sensor code:
1. CLI ran regardless of terminal connection state (wasting cycles)
2. CLI called sensor functions directly (coupling CLI to sensor implementation)
3. USB I/O operations (printf/getchar) were attempted even when terminal wasn't properly connected

The user's key insight: "the CLI menu needs to be completely divorced from any internally running code by its very nature."

### Solution: RC_OS Decoupled Architecture

**Principle:** CLI should be a "local GCS" that translates keystrokes → MAVLink commands internally.

1. **CLI only runs when terminal connected** (`stdio_usb_connected()`):
   - When disconnected: slow LED blink (1Hz), NO USB I/O whatsoever
   - When connected: show banner, process CLI commands

2. **All calibration commands route through internal command dispatch**, not direct sensor calls

3. **Benefits:**
   - CLI and GCS use identical code paths for all operations
   - CLI completely decoupled from sensor internals
   - Terminal connection can't affect flight code
   - Easy to test: CLI commands = MAVLink commands

### Key Code Pattern
```cpp
bool wasConnected = false;

// In main loop:
bool isConnected = stdio_usb_connected();

if (!isConnected) {
    // DISCONNECTED: Just blink LED, NO USB I/O
    led_blink(500);
    wasConnected = false;
} else {
    if (!wasConnected) {
        wasConnected = true;
        // Drain garbage from USB input buffer
        while (getchar_timeout_us(0) != PICO_ERROR_TIMEOUT) {}
        printf("RocketChip OS v0.4\n");
    }
    // Process CLI commands...
}
```

### Prevention
1. **Never do USB I/O unless `stdio_usb_connected()` returns true**
2. **CLI should speak MAVLink internally**, not call sensor functions directly
3. **Terminal connection should only affect output buffering**, not program flow
4. **Drain USB input buffer after terminal connects** - garbage bytes from connection handshake can trigger unwanted commands

---

## Entry 16: PuTTY Truncates Initial USB CDC Output

**Date:** 2026-01-30
**Status:** Documented (host-side issue, not firmware bug)
**Severity:** Low - Cosmetic only

### Problem
Banner output on terminal connection appears truncated - consistently cuts off at the same point regardless of firmware changes.

### Symptoms
- Banner shows: `=== RocketChip OS v0.3.14 ===\nPress 'h' for help, 's' for sen`
- Always cuts off at same spot (~63 characters)
- CLI commands still work after banner
- Multiple attempts at fixing with timing delays, fflush(), puts() vs printf() all failed

### Root Cause
**PuTTY has a known issue with USB CDC serial** where it misses bytes during initial connection handshake. This is a host-side terminal issue, not a firmware bug.

**Key discovery:** VSCode Serial Monitor shows complete output:
```
=== RocketChip OS v0.3.14 ===
Press 'h' for help, 's' for sensor status
```

### Solution
- **Use VSCode Serial Monitor** instead of PuTTY for USB CDC devices
- Documented in `docs/ROCKETCHIP_OS.md` under Terminal Compatibility

### Prevention
1. When debugging output truncation, test with multiple terminal programs
2. VSCode Serial Monitor is more reliable for USB CDC than PuTTY
3. Don't waste time on firmware fixes if issue is terminal-specific

---

## Entry 20: PA1010D GPS Causes I2C Bus Interference When Probed

**Date:** 2026-02-05
**Time Spent:** ~2 hours
**Severity:** High — Makes IMU and baro unusable when GPS is on shared bus

### Problem
After physically removing the GPS from the bus, IVP-13 runs at 0 errors/60s. With the GPS connected and probed during I2C bus scan, IMU gets ~17% read failures and baro gets 100% failures.

### Symptoms
- IMU reads fail periodically (~every 4th read at 10Hz)
- DPS310 baro init succeeds but subsequent reads fail 100%
- Bus scan shows all 3 devices (0x69, 0x77, 0x10) detected
- SDA/SCL pin states both HIGH (bus not electrically stuck)
- Recovery code fires continuously, always "succeeds" but errors resume immediately

### Root Cause
The PA1010D GPS module is fundamentally a UART device with an I2C wrapper. When probed (even a 1-byte read), it starts streaming NMEA data on the I2C bus. This creates bus contention that interferes with IMU and baro transactions.

The Pico SDK had a related issue (#252, fixed in PR #273, SDK 1.2.0) with SDA hold time, but our SDK 2.2.0 already has that fix. The remaining issue is behavioral — the GPS's continuous I2C output after being probed causes timeouts for other devices.

### Solution
1. **Removed GPS from I2C bus scan** — skip address 0x10 in `i2c_bus_scan()`
2. **Removed GPS from expected devices** in `hw_validate_stage1()`
3. **Physically removed GPS module** from Qwiic chain for Stage 2

### Prevention (for IVP-31)
When adding GPS back:
- Read in **small 32-byte chunks** (not the 250-byte reads from pico-examples)
- Filter `0x0A` padding bytes (GPS pads with linefeed when no data ready)
- Poll at GPS sentence rate (1-10Hz), not faster
- Always send STOP condition after reads
- Time-slice: GPS read → IMU read → baro read in main loop
- Do NOT probe GPS during full bus scans

### Reference
- [Pico SDK #252](https://github.com/raspberrypi/pico-sdk/issues/252) — Original SDA hold time bug
- [PR #273](https://github.com/raspberrypi/pico-sdk/pull/273) — Fix merged in SDK 1.2.0
- Adafruit_GPS Arduino library uses 32-byte chunked reads
- CircuitPython uses 1-byte-at-a-time reads with bus lock/unlock

---

## Entry 21: ICM-20948 I2C Master Bank-Switching Race Condition

**Date:** 2026-02-06
**Time Spent:** ~3 hours (across 2 sessions)
**Severity:** Critical — 6-position accel calibration fails deterministically after ~150 reads

### Problem
During 6-position accelerometer calibration, the ICM-20948 returns all zeros after exactly 3 positions (~150 rapid reads). First 3 positions always pass; position 4 onward returns [0.0, 0.0, 0.0].

### Symptoms
- 6-pos calibration completes positions 1-3, zeros at position 4
- Pattern is deterministic: always fails at the same point
- Regular 10Hz sensor polling (IVP-13) works fine — only rapid reads trigger it
- Reducing read size from 23 bytes to 6 bytes (accel-only) didn't help
- Adding `i2c_bus_reset()` between positions didn't help

### Root Cause
The ICM-20948's **internal I2C master** (used for autonomous AK09916 magnetometer reads at 100Hz) shares the **bank-select register (0x7F)** with external reads. The I2C master performs Bank 3 transactions to read mag data. External accel reads use Bank 0.

At 10Hz polling, there's enough time between reads that the bank state is always correct. During rapid calibration reads (back-to-back with minimal delay), the I2C master's Bank 3 switch collides with external Bank 0 reads, corrupting the bank state. After ~150 reads, the corruption accumulates and accel registers return zeros.

**Key insight:** ArduPilot avoids this entirely by using **I2C bypass mode** (`I2C_BYPASS_EN` in `INT_PIN_CFG`) instead of the internal I2C master when the ICM-20948 is on an external I2C bus. The bypass mode connects the AK09916 directly to the external bus, eliminating the bank-switching race.

### Solution
Disable the I2C master during calibration:

```c
// Pre-calibration hook
icm20948_set_i2c_master_enable(&g_imu, false);  // Stops autonomous mag reads

// ... rapid accel reads for calibration ...

// Post-calibration hook
icm20948_set_i2c_master_enable(&g_imu, true);   // Resume mag reads
```

Implemented as pre/post hooks in `rc_os.h` to keep the IMU driver decoupled from the CLI.

### Prevention
1. **When doing rapid sensor reads, disable autonomous internal operations first**
2. **Check ArduPilot's approach** for I2C sensor drivers — they've solved these races
3. **Consider migrating to I2C bypass mode** (ArduPilot's approach) as a permanent fix at a future IVP step — this would eliminate the race entirely
4. **Bank-select register (0x7F) is shared state** — any multi-bank sensor with an internal master has this risk

### Reference
- ArduPilot `AP_InertialSensor_Invensensev2.cpp` — uses bypass mode, not I2C master
- ICM-20948 datasheet Section 11.2 — I2C Master Interface
- `USER_CTRL` register (Bank 0, 0x03) — bit 5 (`I2C_MST_EN`)

---

## Entry 22: USB Reconnect Degrades Core 1 IMU Rate (LiPo-Powered Disconnect)

**Date:** 2026-02-07
**Status:** Observed, not yet root-caused
**Severity:** Medium — stress test edge case, not a flight concern (no USB in flight)

### Problem
During IVP-27 Gate 3 (USB disconnect/reconnect with LiPo keeping MCU powered), Core 1 IMU sampling rate dropped from 999/s to 95/s and never recovered on its own. IMU error count climbed steadily (~5700 errors per minute) while `imu_read_count` froze at 250,756.

### Symptoms
- Before disconnect: Core 1 at 999/s, 0 IMU errors
- After reconnect: Core 1 at 95/s, IMU errors accumulating linearly
- `core1_loop_count` kept advancing (Core 1 alive, just failing reads)
- Baro reads frozen at 2004 (also affected)
- `i2c_bus_reset()` during IVP-28 flash test fixed it — Core 1 recovered to 1000/s

### Likely Root Cause
USB CDC re-enumeration on Core 0 may disrupt I2C bus timing or state. The `stdio_init_all()` USB reconnection path triggers IRQ reconfiguration on Core 0 while Core 1 is mid-I2C-transaction. The I2C peripheral may enter a stuck state that only `i2c_bus_reset()` resolves.

### Workaround
The `i2c_bus_reset()` calls in `ivp28_flash_test()` incidentally fixed it. A deliberate bus reset after USB reconnection would prevent the degradation.

### Prevention (future)
- Consider adding `i2c_bus_reset()` after USB CDC reconnection detection
- Not a flight concern — USB is not connected during flight
- Monitor if this appears in other dual-core scenarios

---

## Entry 23: CLI I2C Scan Corrupts Bus When Core 1 Owns I2C

**Date:** 2026-02-07
**Time Spent:** ~30 minutes
**Severity:** High — bus corruption causes sustained sensor failures

### Problem
During IVP-27 key mash test (first attempt), the 'i' character triggered `i2c_bus_scan()` from Core 0 CLI while Core 1 was actively reading IMU/baro via I2C. This corrupted the bus — Core 1 dropped from 999/s to 95/s, IMU errors exploded to 15,659.

### Root Cause
`i2c_bus_scan()` iterates over all I2C addresses (0x08-0x77), sending probe transactions. When Core 1 is simultaneously reading sensors on the same I2C bus, the probes collide with sensor reads, corrupting the I2C state machine.

### Solution
Added `rc_os_i2c_scan_allowed` flag in `rc_os.h`. Set to `false` when Core 1 enters sensor phase. The 'i' CLI command now prints "I2C scan disabled (Core 1 owns bus)" instead of scanning.

### Prevention
- Any Core 0 function that touches I2C must check if Core 1 owns the bus
- The I2C bus ownership model: Core 0 owns during init, Core 1 owns during sensor phase
- Only `flash_safe_execute()` can safely interrupt Core 1's I2C (via multicore_lockout)

---

## How to Use This Document

1. **Before debugging crashes:** Check if symptoms match any entry here
2. **After significant debugging:** Add new entry with lessons learned
3. **During context recovery:** Read this to restore debugging knowledge
4. **When writing new code:** Apply prevention measures from relevant entries
