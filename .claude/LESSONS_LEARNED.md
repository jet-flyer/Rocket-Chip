# Lessons Learned - Debugging Journal

**Purpose:** Document significant debugging efforts and their solutions so Claude can learn from past issues and avoid repeating mistakes.

**Format:** Each entry includes the problem, symptoms, root cause, solution, and time spent to emphasize the importance of the lesson.

> **Note:** FreeRTOS-specific entries (7, 8, 9, 10, 14, 17, 18, 19) archived with `AP_FreeRTOS` branch during bare-metal pivot. Original entry numbers preserved for traceability.

---

## Plan Files Reference

Plan mode stores plans at `C:\Users\pow-w\.claude\plans\<auto-generated-name>.md`. These persist outside conversations.

**Active Plans:**
- `virtual-scribbling-finch.md` - AP_Vehicle integration for calibration persistence (2026-01-31)

---

## Entry 1: Stack Overflow from Large Local Variables

**Date:** 2026-01-26
**Time Spent:** ~2 hours of debugging
**Severity:** Critical - Silent crashes with no error message

### Problem
Test was crashing mysteriously. Output would appear up to a certain point, then nothing. Crash point seemed to move around between rebuilds.

### Symptoms
- Test prints some output (e.g., "Max fitness: 5.0") then stops
- No error message, no crash dump
- LED/NeoPixel may or may not continue
- Crash point appears random but is actually at function entry
- Clean rebuild sometimes "fixes" it temporarily (different stack layout)

### Root Cause
`CompassCalibrator calibrator;` declared as local variable in `main()`. The CompassCalibrator object is ~3KB+, exceeding available stack space.

**Key insight:** Compiler pre-allocates ALL stack space at function entry, not when variables are used. So even though the crash "appears" to happen after several printf statements, the stack overflow actually occurs immediately when main() is entered.

### Solution
Use static allocation for large objects:

```cpp
// At file scope (outside any function)
static CompassCalibrator g_calibrator;

int main() {
    // Use g_calibrator instead of local variable
    g_calibrator.start(...);
}
```

### How to Identify This Issue
1. Crash point seems to move around between builds
2. Adding/removing printf changes where crash appears
3. Object being created is large (>1KB)
4. Crash happens "between" two printf statements

### Prevention
- Any object >1KB should be static or heap-allocated
- Known large objects: CompassCalibrator, any object with large buffers
- When debugging mysterious crashes, check for large local variables

---

## Entry 2: Version Strings for Iterative Debugging

**Date:** 2026-01-26
**Context:** Debugging stack overflow issue above
**Recurrence:** 2026-02-07 (IVP-30 watchdog debugging — wasted a full 5-min soak + test cycle on old binary)

### Problem
During iterative debugging, it was unclear if the latest code was actually running. Sometimes old binaries were being executed, wasting debugging time.

**IVP-30 recurrence:** After fixing `watchdog_enable_caused_reboot()`, the fix was built but the previous binary was still running on the device. A full 5-minute soak + manual test cycle was wasted before discovering the old binary was loaded. The `__DATE__ __TIME__` stamp was present but not checked — timestamps blur together during rapid debug iterations.

### Solution
Use a **monotonic build iteration tag** that changes with each rebuild during debug sessions:

```cpp
// During debug iteration, use a descriptive tag — INCREMENT ON EACH REBUILD
static const char *kBuildTag = "IVP30-fix-3";
printf("Build: %s (%s %s)\n", kBuildTag, __DATE__, __TIME__);
```

**Why not `__DATE__ __TIME__` alone:**
- Same binary flashed twice looks identical
- Timestamps blur together during rapid rebuilds (same minute)
- A descriptive tag is immediately recognizable in scrollback

**Check the tag in serial output BEFORE starting any test cycle.** A 5-minute soak on the wrong binary is 5 minutes wasted.

### Prevention
- Always use a build iteration tag during extended debug sessions with multiple builds
- Increment the tag on EVERY rebuild, not just "significant" changes
- Verify the tag in serial output before running any test
- When multiple builds happen in the same session, a counter suffix (`-1`, `-2`, `-3`) is clearer than timestamps

---

## Entry 3: BASEPRI Register Blocking USB Interrupts

**Date:** 2026-01-26 (earlier in same session)
**Time Spent:** ~30 minutes

### Problem
USB CDC output not working after initialization code that elevates interrupt priority masking. Terminal shows nothing or partial output.

### Root Cause
Initialization code (HAL, library init, etc.) can leave the ARM BASEPRI register elevated, which blocks USB interrupts.

### Solution
Clear BASEPRI after any init code that might elevate it, before USB I/O:

```cpp
// After init code that might change interrupt priorities
__asm volatile ("mov r0, #0\nmsr basepri, r0" ::: "r0");
stdio_init_all();
```

### Prevention
- If USB stops working after adding init code, check BASEPRI
- Clear BASEPRI before enabling USB if uncertain

---

## Entry 4: Flash Operations Break USB

**Date:** 2026-01-26

### Problem
USB CDC breaks after flash operations during initialization.

### Root Cause
Flash operations make entire flash inaccessible. TinyUSB interrupt handlers are in flash. If USB is active during flash ops, handlers can't execute and USB breaks.

### Solution
Do flash operations BEFORE enabling USB:

```cpp
// Flash ops happen here (calibration load, storage init, etc.)
init_storage();

// NOW safe to start USB
stdio_init_all();
```

### Prevention
- Follow this init order: flash ops first, then USB
- Use `flash_safe_execute()` from `pico/flash.h` for runtime flash access

---

## Entry 5: Use Debug Probe Before Manual BOOTSEL

**Date:** 2026-01-26

### Problem
When debugging crashes, kept asking user to manually reset into BOOTSEL mode when the device became unresponsive.

### Better Approach
Debug probe can always flash the device, even when USB is completely broken:

```bash
arm-none-eabi-gdb firmware.elf -batch \
  -ex "target extended-remote localhost:3333" \
  -ex "monitor reset halt" \
  -ex "load" \
  -ex "monitor reset run"
```

### Prevention
- Always try debug probe first when USB is unresponsive
- Only ask for manual BOOTSEL as last resort
- Keep OpenOCD running during debugging sessions

---

## Entry 6: WS2812/NeoPixel Requires begin() Call

**Date:** 2026-01-26
**Time Spent:** ~1 session (issue not immediately identified)

### Problem
NeoPixel LED was not lighting up at all during compass calibration test, despite code appearing to set colors and call show().

### Symptoms
- LED completely dark, no response to any color commands
- No errors or warnings
- Code runs to completion without issues
- Other test code (without HAL) may show working NeoPixel

### Root Cause
The RocketChip WS2812 class follows standard pattern: construct → `begin()` → use. The `begin()` method:
1. Allocates the pixel buffer
2. Allocates a PIO state machine
3. Loads the PIO program
4. Sets `m_initialized = true`

Without `begin()`, both `setPixel()` and `show()` silently return early:
```cpp
void WS2812::setPixel(uint16_t index, const RGB& color) {
    if (!m_initialized || index >= m_num_leds) {
        return;  // Silent early return!
    }
    // ...
}
```

### Solution
Always call `begin()` after constructing WS2812:

```cpp
g_statusLed = new rh::WS2812(kNeoPixelPin, 1);
if (!g_statusLed->begin()) {
    // Handle init failure
}
g_statusLed->fill(rh::Colors::YELLOW);
g_statusLed->show();
```

### Prevention
- Always follow the construct → begin → use pattern for hardware classes
- Check return value of begin() for failure handling
- When LED doesn't respond, verify begin() was called before assuming hardware issue

---

## Entry 11: Prioritize Debug Probe Over LED Debugging

**Date:** 2026-01-29
**Context:** Multiple debugging sessions where USB was broken
**Severity:** Process Improvement - Saves hours of debugging time

### Problem
When encountering issues that break output (USB enumeration failures, hardfaults, early crashes), default instinct was to add LED blink patterns for diagnostics. This provided minimal information and required many flash/test cycles.

### Better Approach
**Always use the debug probe first.** It provides:
- Register and memory inspection via GDB
- Stack traces showing exact crash location
- Ability to flash even when USB is completely broken
- Variable inspection without modifying code

### Occasional Connection Quirks (Expected)
The probe connection may have transient issues:
- OpenOCD timeout on first attempt
- "Remote communication error" from GDB
- Need to run `monitor reset halt` multiple times

**These are normal** - retry and it works. The probe has proven reliable in extensive debugging sessions. Don't give up after one failed attempt.

### When LED Debugging Makes Sense
Only resort to LED-based debugging when:
- Debug probe is not physically connected
- Observing runtime behavior without breakpoints
- Testing production firmware without probe

### Key Takeaway
The few seconds spent reconnecting a flaky probe connection saves hours compared to iterating with LED blink codes. The probe gives you answers; LEDs give you hints.

---

## Entry 12: USB CDC Init Order Critical for Enumeration

**Date:** 2026-01-29
**Time Spent:** ~1 hour
**Severity:** Critical - USB completely broken (error 2)

### Problem
USB CDC (COM6) failed to enumerate. Device showed "error 2" in Device Manager. Serial output completely broken.

### Symptoms
- USB device doesn't appear in Device Manager
- "error 2" when device tries to enumerate
- LED blink patterns visible (code is running)
- Manual BOOTSEL required to flash

### Root Cause
Init order was wrong — flash operations happened after USB was already active:

**BROKEN order:**
```cpp
stdio_init_all();           // USB starts first
init_storage();             // Flash ops break USB!
```

Flash operations make entire flash inaccessible. TinyUSB interrupt handlers are in flash. When USB is active during flash ops, handlers can't execute and USB breaks permanently.

### Solution
Reorder init:

**WORKING order:**
```cpp
// 1. Flash ops BEFORE USB
init_storage();             // Flash ops complete here

// 2. NOW safe to start USB
stdio_init_all();
```

### Prevention
- **Rule:** Flash operations MUST happen before `stdio_init_all()`
- This is the same root cause as Entry 4

### Related
- Entry 3: BASEPRI blocking USB
- Entry 4: Flash/USB interaction

---

## Entry 13: Adafruit ICM-20948 Default I2C Address is 0x69, not 0x68

**Date:** 2026-01-29
**Time Spent:** ~20 minutes
**Severity:** High - IMU not detected, silent failure

### Problem
IMU (ICM-20948) not being detected. Barometer worked fine (proving I2C bus functional), but zero I2C traffic to the IMU address.

### Symptoms
- Barometer working at 0x77
- IMU: no traffic to 0x68
- I2C debug output shows only 0x77 transfers, never 0x68

### Root Cause
Configuration used **0x68** as the ICM-20948 address, but **Adafruit boards default to 0x69**.

The ICM-20948 has an AD0 pin that controls I2C address:
- AD0 = LOW (grounded) → 0x68
- AD0 = HIGH (or floating) → 0x69

**Adafruit boards pull AD0 HIGH by default**, giving address 0x69. You must bridge the SDO/ADR solder jumper on the back to change to 0x68.

### Solution
Use 0x69 for Adafruit ICM-20948 breakouts (already set in `config.h`).

### Prevention
1. **Always check vendor documentation for default I2C addresses**
2. Run I2C scan test to confirm actual device addresses before configuring
3. For Adafruit boards: check product page or schematic for default pin states
4. Add comments noting whether addresses are vendor defaults vs modified

### Reference
Adafruit ICM-20948 product page confirms 0x69 as default:
https://learn.adafruit.com/adafruit-tdk-invensense-icm-20948-9-dof-imu/pinouts

---

## Entry 15: USB Terminal Connection Affecting Program State

**Date:** 2026-01-30
**Status:** RESOLVED (v0.3.14)
**Severity:** High - CLI unusable
**Time Spent:** ~4 hours (architecture redesign + debugging)

### Problem
CLI stops executing when USB terminal connects. Program behavior should NOT depend on terminal connection - only output buffering should be affected.

### Symptoms
- LED flashes rapidly (50ms) while waiting for sensor init - CORRECT
- When terminal connects to COM6, LED goes SOLID - WRONG
- Pressing Enter does nothing
- Program appears frozen

### Root Cause Analysis
The old CLI architecture was **too tightly coupled** to sensor code:
1. CLI ran regardless of terminal connection state (wasting cycles)
2. CLI called sensor functions directly (coupling CLI to sensor implementation)
3. USB I/O operations (printf/getchar) were attempted even when terminal wasn't properly connected

The user's key insight: "the CLI menu needs to be completely divorced from any internally running code by its very nature."

### Solution: RC_OS Decoupled Architecture

**Principle:** CLI should be a "local GCS" that translates keystrokes → MAVLink commands internally.

1. **CLI only runs when terminal connected** (`stdio_usb_connected()`):
   - When disconnected: slow LED blink (1Hz), NO USB I/O whatsoever
   - When connected: show banner, process CLI commands

2. **All calibration commands route through internal command dispatch**, not direct sensor calls

3. **Benefits:**
   - CLI and GCS use identical code paths for all operations
   - CLI completely decoupled from sensor internals
   - Terminal connection can't affect flight code
   - Easy to test: CLI commands = MAVLink commands

### Key Code Pattern
```cpp
bool wasConnected = false;

// In main loop:
bool isConnected = stdio_usb_connected();

if (!isConnected) {
    // DISCONNECTED: Just blink LED, NO USB I/O
    led_blink(500);
    wasConnected = false;
} else {
    if (!wasConnected) {
        wasConnected = true;
        // Drain garbage from USB input buffer
        while (getchar_timeout_us(0) != PICO_ERROR_TIMEOUT) {}
        printf("RocketChip OS v0.4\n");
    }
    // Process CLI commands...
}
```

### Prevention
1. **Never do USB I/O unless `stdio_usb_connected()` returns true**
2. **CLI should speak MAVLink internally**, not call sensor functions directly
3. **Terminal connection should only affect output buffering**, not program flow
4. **Drain USB input buffer after terminal connects** - garbage bytes from connection handshake can trigger unwanted commands

---

## Entry 16: PuTTY Truncates Initial USB CDC Output

**Date:** 2026-01-30
**Status:** Documented (host-side issue, not firmware bug)
**Severity:** Low - Cosmetic only

### Problem
Banner output on terminal connection appears truncated - consistently cuts off at the same point regardless of firmware changes.

### Symptoms
- Banner shows: `=== RocketChip OS v0.3.14 ===\nPress 'h' for help, 's' for sen`
- Always cuts off at same spot (~63 characters)
- CLI commands still work after banner
- Multiple attempts at fixing with timing delays, fflush(), puts() vs printf() all failed

### Root Cause
**PuTTY has a known issue with USB CDC serial** where it misses bytes during initial connection handshake. This is a host-side terminal issue, not a firmware bug.

**Key discovery:** VSCode Serial Monitor shows complete output:
```
=== RocketChip OS v0.3.14 ===
Press 'h' for help, 's' for sensor status
```

### Solution
- **Use VSCode Serial Monitor** instead of PuTTY for USB CDC devices
- Documented in `docs/ROCKETCHIP_OS.md` under Terminal Compatibility

### Prevention
1. When debugging output truncation, test with multiple terminal programs
2. VSCode Serial Monitor is more reliable for USB CDC than PuTTY
3. Don't waste time on firmware fixes if issue is terminal-specific

---

## Entry 20: PA1010D GPS Causes I2C Bus Interference When Probed

**Date:** 2026-02-05
**Time Spent:** ~2 hours
**Severity:** High — Makes IMU and baro unusable when GPS is on shared bus

### Problem
After physically removing the GPS from the bus, IVP-13 runs at 0 errors/60s. With the GPS connected and probed during I2C bus scan, IMU gets ~17% read failures and baro gets 100% failures.

### Symptoms
- IMU reads fail periodically (~every 4th read at 10Hz)
- DPS310 baro init succeeds but subsequent reads fail 100%
- Bus scan shows all 3 devices (0x69, 0x77, 0x10) detected
- SDA/SCL pin states both HIGH (bus not electrically stuck)
- Recovery code fires continuously, always "succeeds" but errors resume immediately

### Root Cause
The PA1010D GPS module is fundamentally a UART device with an I2C wrapper. When probed (even a 1-byte read), it starts streaming NMEA data on the I2C bus. This creates bus contention that interferes with IMU and baro transactions.

The Pico SDK had a related issue (#252, fixed in PR #273, SDK 1.2.0) with SDA hold time, but our SDK 2.2.0 already has that fix. The remaining issue is behavioral — the GPS's continuous I2C output after being probed causes timeouts for other devices.

### Solution
1. **Removed GPS from I2C bus scan** — skip address 0x10 in `i2c_bus_scan()`
2. **Removed GPS from expected devices** in `hw_validate_stage1()`
3. **Physically removed GPS module** from Qwiic chain for Stage 2

### Prevention (for IVP-31)
When adding GPS back:
- Read in **small 32-byte chunks** (not the 250-byte reads from pico-examples)
- Filter `0x0A` padding bytes (GPS pads with linefeed when no data ready)
- Poll at GPS sentence rate (1-10Hz), not faster
- Always send STOP condition after reads
- Time-slice: GPS read → IMU read → baro read in main loop
- Do NOT probe GPS during full bus scans

### Reference
- [Pico SDK #252](https://github.com/raspberrypi/pico-sdk/issues/252) — Original SDA hold time bug
- [PR #273](https://github.com/raspberrypi/pico-sdk/pull/273) — Fix merged in SDK 1.2.0
- Adafruit_GPS Arduino library uses 32-byte chunked reads
- CircuitPython uses 1-byte-at-a-time reads with bus lock/unlock

---

## Entry 21: ICM-20948 I2C Master Bank-Switching Race Condition

**Date:** 2026-02-06
**Time Spent:** ~3 hours (across 2 sessions)
**Severity:** Critical — 6-position accel calibration fails deterministically after ~150 reads

### Problem
During 6-position accelerometer calibration, the ICM-20948 returns all zeros after exactly 3 positions (~150 rapid reads). First 3 positions always pass; position 4 onward returns [0.0, 0.0, 0.0].

### Symptoms
- 6-pos calibration completes positions 1-3, zeros at position 4
- Pattern is deterministic: always fails at the same point
- Regular 10Hz sensor polling (IVP-13) works fine — only rapid reads trigger it
- Reducing read size from 23 bytes to 6 bytes (accel-only) didn't help
- Adding `i2c_bus_reset()` between positions didn't help

### Root Cause
The ICM-20948's **internal I2C master** (used for autonomous AK09916 magnetometer reads at 100Hz) shares the **bank-select register (0x7F)** with external reads. The I2C master performs Bank 3 transactions to read mag data. External accel reads use Bank 0.

At 10Hz polling, there's enough time between reads that the bank state is always correct. During rapid calibration reads (back-to-back with minimal delay), the I2C master's Bank 3 switch collides with external Bank 0 reads, corrupting the bank state. After ~150 reads, the corruption accumulates and accel registers return zeros.

**Key insight:** ArduPilot avoids this entirely by using **I2C bypass mode** (`I2C_BYPASS_EN` in `INT_PIN_CFG`) instead of the internal I2C master when the ICM-20948 is on an external I2C bus. The bypass mode connects the AK09916 directly to the external bus, eliminating the bank-switching race.

### Solution
Disable the I2C master during calibration:

```c
// Pre-calibration hook
icm20948_set_i2c_master_enable(&g_imu, false);  // Stops autonomous mag reads

// ... rapid accel reads for calibration ...

// Post-calibration hook
icm20948_set_i2c_master_enable(&g_imu, true);   // Resume mag reads
```

Implemented as pre/post hooks in `rc_os.h` to keep the IMU driver decoupled from the CLI.

### Prevention
1. **When doing rapid sensor reads, disable autonomous internal operations first**
2. **Check ArduPilot's approach** for I2C sensor drivers — they've solved these races
3. **Consider migrating to I2C bypass mode** (ArduPilot's approach) as a permanent fix at a future IVP step — this would eliminate the race entirely
4. **Bank-select register (0x7F) is shared state** — any multi-bank sensor with an internal master has this risk

### Reference
- ArduPilot `AP_InertialSensor_Invensensev2.cpp` — uses bypass mode, not I2C master
- ICM-20948 datasheet Section 11.2 — I2C Master Interface
- `USER_CTRL` register (Bank 0, 0x03) — bit 5 (`I2C_MST_EN`)

---

## Entry 22: USB Reconnect Degrades Core 1 IMU Rate (LiPo-Powered Disconnect)

**Date:** 2026-02-07
**Status:** Observed, not yet root-caused
**Severity:** Medium — stress test edge case, not a flight concern (no USB in flight)

### Problem
During IVP-27 Gate 3 (USB disconnect/reconnect with LiPo keeping MCU powered), Core 1 IMU sampling rate dropped from 999/s to 95/s and never recovered on its own. IMU error count climbed steadily (~5700 errors per minute) while `imu_read_count` froze at 250,756.

### Symptoms
- Before disconnect: Core 1 at 999/s, 0 IMU errors
- After reconnect: Core 1 at 95/s, IMU errors accumulating linearly
- `core1_loop_count` kept advancing (Core 1 alive, just failing reads)
- Baro reads frozen at 2004 (also affected)
- `i2c_bus_reset()` during IVP-28 flash test fixed it — Core 1 recovered to 1000/s

### Likely Root Cause
USB CDC re-enumeration on Core 0 may disrupt I2C bus timing or state. The `stdio_init_all()` USB reconnection path triggers IRQ reconfiguration on Core 0 while Core 1 is mid-I2C-transaction. The I2C peripheral may enter a stuck state that only `i2c_bus_reset()` resolves.

### Workaround
The `i2c_bus_reset()` calls in `ivp28_flash_test()` incidentally fixed it. A deliberate bus reset after USB reconnection would prevent the degradation.

### Prevention (future)
- Consider adding `i2c_bus_reset()` after USB CDC reconnection detection
- Not a flight concern — USB is not connected during flight
- Monitor if this appears in other dual-core scenarios

---

## Entry 23: CLI I2C Scan Corrupts Bus When Core 1 Owns I2C

**Date:** 2026-02-07
**Time Spent:** ~30 minutes
**Severity:** High — bus corruption causes sustained sensor failures

### Problem
During IVP-27 key mash test (first attempt), the 'i' character triggered `i2c_bus_scan()` from Core 0 CLI while Core 1 was actively reading IMU/baro via I2C. This corrupted the bus — Core 1 dropped from 999/s to 95/s, IMU errors exploded to 15,659.

### Root Cause
`i2c_bus_scan()` iterates over all I2C addresses (0x08-0x77), sending probe transactions. When Core 1 is simultaneously reading sensors on the same I2C bus, the probes collide with sensor reads, corrupting the I2C state machine.

### Solution
Added `rc_os_i2c_scan_allowed` flag in `rc_os.h`. Set to `false` when Core 1 enters sensor phase. The 'i' CLI command now prints "I2C scan disabled (Core 1 owns bus)" instead of scanning.

### Prevention
- Any Core 0 function that touches I2C must check if Core 1 owns the bus
- The I2C bus ownership model: Core 0 owns during init, Core 1 owns during sensor phase
- Only `flash_safe_execute()` can safely interrupt Core 1's I2C (via multicore_lockout)

---

## Entry 24: PA1010D I2C Bus Contention — 500us Settling Delay Fix

**Date:** 2026-02-08
**Time Spent:** ~3 hours (gps-11 through gps-12c, 4 controlled isolation tests)
**Severity:** High — 8.4% IMU error rate on shared I2C bus

### Problem
With PA1010D GPS polling at 10Hz on Core 1 (shared I2C bus with ICM-20948 IMU and DPS310 baro), the IMU suffered ~8.4% read failure rate (16,300 errors / 194,831 reads). GPS itself had 7.9% error rate.

### Symptoms
- ~8 consecutive IMU failures after each GPS read, then natural recovery
- Baro unaffected (0 errors) — its reads are less timing-sensitive
- Pattern deterministic: always bursts of ~8 failures per GPS cycle
- `i2c_bus_recover()` at 10Hz made it WORSE (99.7% GPS failure in gps-11) — GPIO_FUNC_SIO/I2C switching in hot loop corrupts the I2C peripheral

### Root Cause
The PA1010D (MT3333 chipset) is a UART-over-I2C bridge. After a 255-byte read completes with STOP condition, the MT3333 briefly holds SDA low while its internal UART buffer replenishes. The next IMU bank-select write (`i2c_bus_write_reg(0x69, 0x7F, 0)`) fails because SDA is not yet released.

This is purely electrical/bus-level behavior — independent of GPS satellite lock. The MT3333 always fills its 255-byte buffer whether sending valid NMEA or padding.

### Solution
Add 500us `busy_wait_us()` after each GPS I2C read, before allowing the next IMU read.

```cpp
bool parsed = gps_pa1010d_update();
busy_wait_us(500);  // PA1010D SDA settling
```

**Cost:** 500us × 10Hz = 5ms/sec = 0.5% CPU overhead. ~0.5 missed IMU samples per GPS cycle.

### Isolation Test Results

| Build | GPS Rate | Delay | IMU Errors | GPS Errors |
|-------|----------|-------|------------|------------|
| gps-10 | 10Hz | none | 8.4% (16,300) | 7.9% (166) |
| gps-12a | 5Hz | 500us | 0% | 0% |
| gps-12b | 5Hz | none | 0% | 0% |
| gps-12c | 10Hz | 500us | 0% | 0% |

**Key finding:** Either the 500us delay OR reducing to 5Hz independently eliminates contention. The delay is preferred — it allows 10Hz GPS with negligible overhead.

### Prevention
1. **UART-over-I2C devices need settling time** after bulk reads on shared buses
2. **Never use `i2c_bus_recover()` in a hot loop** — it switches GPIO function, corrupting the I2C peripheral. Reserve for rare error recovery only
3. **For production:** Use UART GPS (FeatherWing) to eliminate I2C contention entirely. I2C GPS mode with auto-detected settling delay for plug-and-play tier
4. **ArduPilot never shares GPS with high-rate sensors on I2C** — always separate bus or UART

---

## Entry 25: Use Debug Probe for Flashing — picotool Corrupts I2C Bus

**Date:** 2026-02-09
**Time Spent:** ~1.5 hours (wasted on false BSS regression diagnosis)
**Severity:** Critical — Process improvement that prevents hours of wasted debugging

### Problem
During clang-tidy remediation, Phase 1 changes (adding `static_cast<float>()` to sensor conversions) appeared to cause a BSS layout regression — 100% IMU init failures, 0 successful reads. Multiple bisection rounds suggested the icm20948.cpp changes were the trigger. Reverted everything, baseline also started failing. Nearly wrote off the changes as triggering the known BSS sensitivity issue.

### Symptoms
- `[FAIL] ICM-20948 init failed` and `[FAIL] DPS310 init failed` in boot banner
- 0 successful sensor reads, error count climbing continuously
- Baseline binary also failed after enough flash cycles
- Symptoms identical to the BSS layout regression (IVP-32/33)

### Root Cause
**`picotool load --force` corrupts the I2C bus across consecutive rapid flash cycles.** The `--force` flag sends a USB vendor command to reboot into BOOTSEL, which interrupts any in-progress I2C transaction. The bus recovery code at init handles ONE interrupted transaction, but rapid successive reboots (5-10 flash cycles during bisection testing) accumulate corruption that bus recovery can't clear.

This was misdiagnosed as a code regression / BSS layout sensitivity issue because:
1. The first flash of modified code failed (bus already degraded from prior cycles)
2. Reverting to baseline also failed (bus was degraded regardless of code)
3. A lucky power cycle during bisection cleared the bus temporarily, making one test pass and confusing the analysis

### Solution
**Always use the debug probe (SWD) for flashing during iterative development:**

```bash
# Start OpenOCD (once per session)
taskkill //F //IM openocd.exe 2>/dev/null; sleep 2
/c/Users/pow-w/.pico-sdk/openocd/0.12.0+dev/openocd \
  -s /c/Users/pow-w/.pico-sdk/openocd/0.12.0+dev/scripts \
  -f interface/cmsis-dap.cfg -f target/rp2350.cfg \
  -c "adapter speed 5000" &

# Flash and run (each iteration)
/c/Users/pow-w/.pico-sdk/toolchain/14_2_Rel1/bin/arm-none-eabi-gdb.exe \
  build/rocketchip.elf -batch \
  -ex "target extended-remote localhost:3333" \
  -ex "monitor reset halt" \
  -ex "load" \
  -ex "monitor reset run"
```

The debug probe:
- Halts both cores cleanly before flashing (no mid-transaction interruption)
- Resets via SWD, not USB (no I2C bus corruption)
- Provides reliable state after flash (no need for power cycles between iterations)
- Eliminates the entire class of "picotool reboot" debugging failures

### When picotool Is Still OK
- Single flash-and-go (not iterative testing)
- When debug probe is not physically connected
- Production flashing (one-shot, followed by power cycle)

### Prevention
1. **Debug probe is the default for all iterative development.** picotool is the fallback, not the primary tool
2. **If using picotool, power cycle between flash cycles** — don't rely on the `--force` reboot alone
3. **When sensor init fails after a code change, first rule out bus corruption** — flash the known-good baseline via probe before concluding it's a code regression
4. **Never bisect code changes using picotool** — the accumulated bus corruption produces false positives that waste hours

### Impact
This entry supersedes the picotool guidance in DEBUG_PROBE_NOTES.md and DEBUG_OUTPUT.md. The debug probe was previously described as "for debugging only" — it is now the **primary recommended flashing tool** for iterative development.

---

## Entry 26: JSF AV Rule 213 — Arithmetic Parentheses Disabled in Clang-Tidy

**Date:** 2026-02-09
**Context:** First clang-tidy audit — 65 `readability-math-missing-parentheses` findings
**Severity:** Process — clang-tidy config decision, not a code bug

### Problem
clang-tidy flagged 65 instances of `readability-math-missing-parentheses` in sensor conversion math, matrix operations, and physics formulas. JSF AV Rule 213 requires explicit parentheses for operator precedence clarity.

### Analysis
Reviewed NASA/JPL's actual practice: their Power of 10 rules and institutional standards do NOT require parenthesizing well-understood arithmetic expressions like `a * b + c`. Rule 213 targets genuinely ambiguous precedence (bitwise operators mixed with arithmetic, logical operators mixed with comparison, ternary expressions). Standard mathematical expressions where `*` and `/` clearly bind tighter than `+` and `-` are universally understood by embedded engineers.

The clang-tidy check is overly aggressive — it flags `ax * scale + offset` as needing `(ax * scale) + offset`, which adds visual noise without improving clarity. For matrix math and sensor conversions, the added parentheses make the code harder to read, not easier.

### Solution
Disabled `readability-math-missing-parentheses` in `.clang-tidy` config with comment:

```yaml
# readability-math-missing-parentheses: disabled — JSF AV Rule 213 exemption.
# NASA/JPL practice: standard arithmetic precedence (* / before + -) is
# universally understood. Parenthesizing a*b+c as (a*b)+c adds noise.
# Reserve explicit parens for genuinely ambiguous cases (bitwise, ternary).
```

### Prevention
1. **Bitwise + arithmetic mixing still requires parentheses** — e.g., `(flags & mask) != 0` not `flags & mask != 0`
2. **Ternary expressions still require parentheses** — JSF AV Rule 213 applies
3. **Logical operator mixing still requires parentheses** — `(a && b) || c` not `a && b || c`
4. **Standard math is exempt** — `a * b + c`, `x / y - z`, etc. do not need explicit parens

### Reference
- JSF AV C++ Rule 213: "Parentheses should be used to indicate precedence"
- NASA/JPL Power of 10, Rule 3: about reducing preprocessor use, not arithmetic parens
- Clang-tidy check `readability-math-missing-parentheses`: too aggressive for embedded math

---

## Entry 27: "Codegen Sensitivity" Was Picotool Bus Corruption All Along

**Date:** 2026-02-09
**Time Spent:** ~3 hours (1.5h original misdiagnosis from Entry 25 + 1.5h definitive disproof test)
**Severity:** Critical — Process lesson. False hypothesis blocked i2c_bus.cpp improvements for days.

### Problem
A hypothesis developed over multiple sessions that changes to `i2c_bus.cpp` or `main.cpp` BSS layout caused I2C degradation after 40-90 seconds of operation. This was documented in the AGENT_WHITEBOARD as "BSS Layout / Codegen Sensitivity — UNSOLVED, DEFERRED" and led to avoidance of any modifications to flight-critical source files.

### The Flawed Evidence Chain
1. Modified binary → I2C degradation after 40-90s of soak testing
2. Reverted binary → also failed
3. Conclusion: "ANY binary change triggers codegen sensitivity"

### Root Cause: Contaminated Methodology
**All prior soak tests that produced the "codegen sensitivity" evidence were flashed via `picotool --force`.** LL Entry 25 later proved that picotool rapid flash cycles corrupt the I2C bus (the `--force` USB reboot interrupts in-progress I2C transactions). The accumulated bus corruption was misattributed to code changes.

The misdiagnosis was self-reinforcing:
- Modified code failed (bus already degraded from prior picotool cycles)
- Reverted code also failed (bus degraded regardless of code)
- Lucky power cycles between tests occasionally cleared the bus, making random tests pass and further confusing analysis

### Definitive Disproof Test
Three 6-minute soak tests, all flashed via **debug probe (SWD)** — which halts both cores cleanly before flashing, no mid-transaction interruption:

| Test | Binary Change | IMU Reads | IMU Errors | Rate |
|------|--------------|-----------|------------|------|
| Baseline | None (`prod-1`) | 398,665 | **0** | ~931/s |
| Test 1 | `constexpr` added to i2c_bus.cpp | 369,604 | **0** | ~931/s |
| Test 2 | `static volatile` added to i2c_bus.cpp (BSS change) | 369,549 | **0** | ~931/s |

Zero errors across all three tests. The BSS layout change in Test 2 would have been the exact trigger for the hypothesized "codegen sensitivity."

### What This Means
- **No BSS isolation needed.** No `__attribute__((section))`, no separate `.cpp` files for globals.
- **No BUSCTRL investigation needed.** Memory bus contention was never the issue.
- **No `.map` / `objdump -d` diff needed.** There's nothing wrong with the codegen.
- **i2c_bus.cpp can be freely modified.** Flash via probe and changes are safe.
- **The prod-13 through prod-16 USB changes should be retested via probe.** Their soak failures may have been entirely picotool artifacts.

### Prevention
1. **Never use picotool for iterative soak testing.** Debug probe is the only reliable method for consecutive flash cycles. (Reinforces LL Entry 25.)
2. **When a hypothesis is built on flawed methodology, re-run the test with correct methodology before investing in workarounds.** The codegen sensitivity investigation paths (BSS isolation, section attributes, BUSCTRL counters) would have been wasted work.
3. **Question persistent "unsolved" issues.** If a problem defies explanation, the most likely cause is a confound in the test setup, not a mysterious hardware behavior.

---

## How to Use This Document

1. **Before debugging crashes:** Check if symptoms match any entry here
2. **After significant debugging:** Add new entry with lessons learned
3. **During context recovery:** Read this to restore debugging knowledge
4. **When writing new code:** Apply prevention measures from relevant entries
